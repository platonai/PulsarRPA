name: Docker Build
description: Build Docker images with multi-platform support and optimization
author: platonai
branding:
  icon: 'box'
  color: 'blue'

inputs:
  image_name:
    description: 'Docker image name (required)'
    required: true
  version:
    description: 'Image version/tag (required)'
    required: true
  dockerfile:
    description: 'Dockerfile path (default: Dockerfile)'
    required: false
    default: 'Dockerfile'
  build_context:
    description: 'Build context path (default: .)'
    required: false
    default: '.'
  timeout_minutes:
    description: 'Build timeout in minutes (default: 15)'
    required: false
    default: '15'
  platforms:
    description: 'Target platforms (default: linux/amd64)'
    required: false
    default: 'linux/amd64'
  build_args:
    description: 'Build arguments (key=value, one per line)'
    required: false
    default: ''
  cache_from:
    description: 'Cache source images'
    required: false
    default: ''
  push_image:
    description: 'Push image after build (default: false)'
    required: false
    default: 'false'
  show_layer_details:
    description: 'Show detailed layer information (default: true)'
    required: false
    default: 'true'

outputs:
  image_id:
    description: 'Built image ID'
    value: ${{ steps.build.outputs.image_id }}
  image_digest:
    description: 'Image digest'
    value: ${{ steps.build.outputs.digest }}
  image_size:
    description: 'Image size in bytes'
    value: ${{ steps.image-info.outputs.size }}
  image_size_mb:
    description: 'Image size in MB'
    value: ${{ steps.image-info.outputs.size_mb }}

runs:
  using: "composite"
  steps:
    - name: Validate Build Context
      shell: bash
      run: |
        echo "::group::Build Context Validation"

        if [ ! -f "${{ inputs.dockerfile }}" ]; then
          echo "‚ùå Dockerfile not found: ${{ inputs.dockerfile }}"
          exit 1
        fi

        if [ ! -d "${{ inputs.build_context }}" ]; then
          echo "‚ùå Build context directory not found: ${{ inputs.build_context }}"
          exit 1
        fi

        echo "‚úÖ Dockerfile found: ${{ inputs.dockerfile }}"
        echo "‚úÖ Build context: ${{ inputs.build_context }}"

        # Show Dockerfile content summary
        echo ""
        echo "üìã Dockerfile summary:"
        echo "  - Size: $(wc -l < ${{ inputs.dockerfile }}) lines"

        # Get base image safely
        base_image=$(grep -m1 '^FROM' "${{ inputs.dockerfile }}" | awk '{print $2}' || echo 'unknown')
        echo "  - Base image: $base_image"

        # Check for multi-stage builds
        stage_count=$(grep -c '^FROM' "${{ inputs.dockerfile }}" || echo "1")
        if [ $stage_count -gt 1 ]; then
          echo "  - Multi-stage build: $stage_count stages"
        fi

        echo "::endgroup::"

    - name: Pre-build Disk Usage (Diagnostics)
      shell: bash
      run: |
        echo "::group::Pre-build Disk Usage"
        df -h || true
        echo ""
        echo "üê≥ docker system df:"
        docker system df -v || docker system df || true
        echo "::endgroup::"

    - name: Pre-build Cleanup (Workspace Temp Files)
      shell: bash
      run: |
        echo "::group::Pre-build Cleanup"

        # Goal: remove temporary/build artifacts generated by previous steps (e.g. tests) to free space.
        # Safety: only delete reproducible build outputs; keep source, git metadata, and Maven local repo.
        #
        # NOTE: Don't blindly delete every directory named "target"/"build".
        # Some repos may contain fixture or source directories with those names (e.g. src/**/target).

        ROOT="${GITHUB_WORKSPACE:-$PWD}"
        cd "$ROOT"

        # Resolve absolute path in a portable way (realpath might not exist on all runners).
        abs_path() {
          if command -v realpath >/dev/null 2>&1; then
            realpath "$1"
          else
            python -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$1"
          fi
        }

        safe_rm_dir() {
          local p="$1"
          [ -z "$p" ] && return 0

          # Refuse symlinks (avoid deleting outside workspace by accident)
          if [ -L "$p" ]; then
            echo "‚ö†Ô∏è  Skip symlink: $p"
            return 0
          fi

          local ap
          ap="$(abs_path "$p")"
          local root_ap
          root_ap="$(abs_path "$ROOT")"

          # Must be inside the workspace
          case "$ap" in
            "$root_ap"/*) ;;
            *)
              echo "‚ö†Ô∏è  Skip out-of-workspace path: $p -> $ap"
              return 0
              ;;
          esac

          # Never delete anything under source/resource trees
          case "$ap" in
            */src/*|*/src/main/*|*/src/test/*|*/resources/*|*/test/*|*/tests/*|*/fixtures/*)
              echo "‚ö†Ô∏è  Skip source/resource tree: $p"
              return 0
              ;;
          esac

          if [ -d "$p" ]; then
            echo "üßπ Removing directory: $p"
            rm -rf "$p" 2>/dev/null || true
          fi
        }

        echo "üßπ Removing Maven/Gradle build outputs (target/build directories; safe mode)..."
        # Only consider module/root build outputs; avoid deep traversal to reduce risk.
        # Depth 2 covers: ./target, ./module/target, ./module/build
        while IFS= read -r d; do
          safe_rm_dir "$d"
        done < <(find . -maxdepth 2 -type d \( -name target -o -name build \) -print 2>/dev/null || true)

        echo "üßπ Removing Maven Surefire/Failsafe reports and temp dirs..."
        # These are standard Maven test outputs; still apply the safe delete guard.
        while IFS= read -r d; do
          safe_rm_dir "$d"
        done < <(find . -maxdepth 4 -type d \( -name surefire-reports -o -name failsafe-reports -o -name .surefire -o -name .failsafe \) -print 2>/dev/null || true)

        echo "üßπ Removing common test temp folders..."
        while IFS= read -r d; do
          safe_rm_dir "$d"
        done < <(find . -maxdepth 4 -type d \( -name tmp -o -name temp -o -name .tmp \) -print 2>/dev/null || true)

        echo "üßπ Cleaning OS temp (best-effort)..."
        rm -rf /tmp/* 2>/dev/null || true

        echo "‚úÖ Done. Disk usage after cleanup:"
        df -h || true

        echo "::endgroup::"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: ${{ inputs.platforms }}

    - name: Prepare Build Arguments
      shell: bash
      run: |
        echo "::group::Build Preparation"

        # Process build arguments
        if [ -n "${{ inputs.build_args }}" ]; then
          echo "üìã Build arguments:"
          echo "${{ inputs.build_args }}" | while IFS= read -r arg; do
            if [ -n "$arg" ]; then
              echo "  - $arg"
            fi
          done
        fi

        # Prepare tags
        TAGS="${{ inputs.image_name }}:${{ inputs.version }}"

        # Add latest tag if version is not a snapshot or pre-release
        if [[ "${{ inputs.version }}" != *"SNAPSHOT"* ]] && [[ "${{ inputs.version }}" != *"-"* ]] && [[ "${{ inputs.version }}" != *"alpha"* ]] && [[ "${{ inputs.version }}" != *"beta"* ]] && [[ "${{ inputs.version }}" != *"rc"* ]]; then
          TAGS="$TAGS,${{ inputs.image_name }}:latest"
        fi

        echo "DOCKER_TAGS=$TAGS" >> $GITHUB_ENV

        echo "üìã Tags to be created:"
        echo "$TAGS" | tr ',' '\n' | sed 's/^/  - /'

        echo "::endgroup::"

    - name: Build Docker Image
      id: build
      shell: bash
      run: |
        echo "::group::Docker Build"

        start_time=$(date +%s)

        echo "üê≥ Building Docker image..."
        echo "üìã Build Configuration:"
        echo "  - Image: ${{ inputs.image_name }}"
        echo "  - Version: ${{ inputs.version }}"
        echo "  - Dockerfile: ${{ inputs.dockerfile }}"
        echo "  - Context: ${{ inputs.build_context }}"
        echo "  - Platforms: ${{ inputs.platforms }}"
        echo "  - Timeout: ${{ inputs.timeout_minutes }} minutes"

        # Build docker command
        build_cmd="docker buildx build"
        build_cmd="$build_cmd --file ${{ inputs.dockerfile }}"
        build_cmd="$build_cmd --platform ${{ inputs.platforms }}"

        # Add tags
        for tag in $(echo "$DOCKER_TAGS" | tr ',' ' '); do
          build_cmd="$build_cmd --tag $tag"
        done

        # Add build arguments
        if [ -n "${{ inputs.build_args }}" ]; then
          echo "${{ inputs.build_args }}" | while IFS= read -r arg; do
            if [ -n "$arg" ]; then
              build_cmd="$build_cmd --build-arg $arg"
            fi
          done
        fi

        # Add cache configuration
        if [ -n "${{ inputs.cache_from }}" ]; then
          build_cmd="$build_cmd --cache-from ${{ inputs.cache_from }}"
        fi

        # Add push option
        if [ "${{ inputs.push_image }}" == "true" ]; then
          build_cmd="$build_cmd --push"
        else
          build_cmd="$build_cmd --load"
        fi

        # Add build context
        build_cmd="$build_cmd ${{ inputs.build_context }}"

        echo "üöÄ Executing: $build_cmd"
        echo ""

        # Execute with timeout
        timeout_seconds=$(( ${{ fromJSON(inputs.timeout_minutes) }} * 60 ))

        if timeout $timeout_seconds $build_cmd; then
          end_time=$(date +%s)
          build_time=$((end_time - start_time))
          echo ""
          echo "‚úÖ Docker image built successfully in ${build_time} seconds"

          # Get image ID (only works if not pushing)
          if [ "${{ inputs.push_image }}" != "true" ]; then
            image_id=$(docker images --format "{{.ID}}" "${{ inputs.image_name }}:${{ inputs.version }}" | head -1)
            echo "image_id=$image_id" >> $GITHUB_OUTPUT
          fi

        else
          end_time=$(date +%s)
          build_time=$((end_time - start_time))
          echo ""
          echo "‚ùå Docker build failed or timed out after ${build_time} seconds"
          exit 1
        fi

        echo "::endgroup::"

    - name: Post-build Cleanup (Buildx/Docker Cache)
      if: always()
      shell: bash
      run: |
        echo "::group::Post-build Cleanup"

        # Lightweight cleanup to keep the runner healthy without destroying all caches.
        echo "üßπ Pruning Buildx cache (older than 2h)..."
        docker buildx prune -af --filter "until=2h" 2>/dev/null || true

        echo "üßπ Pruning dangling images..."
        docker image prune -f 2>/dev/null || true

        echo "üßπ Pruning stopped containers..."
        docker container prune -f 2>/dev/null || true

        echo "üßπ Cleaning /tmp (best-effort)..."
        rm -rf /tmp/* 2>/dev/null || true

        echo "‚úÖ Disk usage after post-build cleanup:"
        df -h || true

        echo "::endgroup::"

    - name: Failure Cleanup (Aggressive)
      if: failure()
      shell: bash
      run: |
        echo "::group::Failure Cleanup (Aggressive)"

        echo "‚ö†Ô∏è Build failed - attempting aggressive cleanup to free disk for retry/debug..."
        echo "Before aggressive cleanup:"
        df -h || true
        docker system df -v || docker system df || true

        # BuildKit/buildx cache + unused docker data.
        docker buildx prune -af 2>/dev/null || true
        docker system prune -af --volumes 2>/dev/null || true

        echo "After aggressive cleanup:"
        df -h || true
        docker system df -v || docker system df || true

        echo ""
        echo "üì¶ /mnt usage (focused):"
        df -h /mnt 2>/dev/null || true

        echo ""
        echo "üì¶ Largest directories under /mnt (>= 100MB):"
        if [ -d /mnt ] && command -v du >/dev/null 2>&1; then
          # -x: stay on one filesystem; -m: sizes in MB; -d 3: limit depth to keep output manageable.
          du -x -m -d 3 /mnt 2>/dev/null | awk '$1 >= 100 {print}' | sort -nr | head -200 || true
        else
          echo "Skipping: /mnt not present or du unavailable"
        fi

        echo "::endgroup::"

    - name: Image Information
      id: image-info
      if: success() && inputs.push_image != 'true'
      shell: bash
      run: |
        echo "::group::Image Information"

        echo "üìä Built images:"
        docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}" | \
          grep "${{ inputs.image_name }}" || true

        # Get detailed image information
        image_name="${{ inputs.image_name }}:${{ inputs.version }}"

        if docker image inspect "$image_name" > /dev/null 2>&1; then
          # Get image size
          size=$(docker image inspect "$image_name" --format '{{.Size}}' 2>/dev/null || echo "0")
          size_mb=$((size / 1024 / 1024))

          echo "size=$size" >> $GITHUB_OUTPUT
          echo "size_mb=$size_mb" >> $GITHUB_OUTPUT

          echo ""
          echo "üìã Image Details:"
          echo "  - Name: $image_name"
          echo "  - Size: ${size_mb} MB"

          # Get architecture and OS safely
          architecture=$(docker image inspect "$image_name" --format '{{.Architecture}}' 2>/dev/null || echo "unknown")
          os=$(docker image inspect "$image_name" --format '{{.Os}}' 2>/dev/null || echo "unknown")

          echo "  - Architecture: $architecture"
          echo "  - OS: $os"

          # Get creation date
          created=$(docker image inspect "$image_name" --format '{{.Created}}' 2>/dev/null || echo "unknown")
          echo "  - Created: $created"

          # Show layer information with better error handling
          if [ "${{ inputs.show_layer_details }}" == "true" ]; then
            echo ""
            echo "üì¶ Image layers (top 10):"

            # Use a more robust approach to show layers
            if docker history "$image_name" --format "table {{.CreatedBy}}\t{{.Size}}" --no-trunc 2>/dev/null | head -11 > /tmp/layer_info.txt; then
              cat /tmp/layer_info.txt || echo "Unable to display layer information"
              rm -f /tmp/layer_info.txt
            else
              echo "‚ö†Ô∏è Unable to retrieve detailed layer information"

              # Fallback: show basic layer count
              layer_count=$(docker history "$image_name" --quiet 2>/dev/null | wc -l || echo "unknown")
              echo "  - Total layers: $layer_count"
            fi
          fi

          # Show image configuration summary
          echo ""
          echo "‚öôÔ∏è Image Configuration:"

          # Get exposed ports
          exposed_ports=$(docker image inspect "$image_name" --format '{{range $port, $config := .Config.ExposedPorts}}{{$port}} {{end}}' 2>/dev/null | tr '\n' ' ' || echo "none")
          echo "  - Exposed Ports: ${exposed_ports:-none}"

          # Get environment variables count
          env_count=$(docker image inspect "$image_name" --format '{{len .Config.Env}}' 2>/dev/null || echo "0")
          echo "  - Environment Variables: $env_count"

          # Get entrypoint
          entrypoint=$(docker image inspect "$image_name" --format '{{.Config.Entrypoint}}' 2>/dev/null | sed 's/\[//g' | sed 's/\]//g' | tr -d '"' || echo "none")
          if [ "$entrypoint" != "none" ] && [ "$entrypoint" != "<no value>" ] && [ -n "$entrypoint" ]; then
            echo "  - Entrypoint: $entrypoint"
          fi

          # Get CMD
          cmd=$(docker image inspect "$image_name" --format '{{.Config.Cmd}}' 2>/dev/null | sed 's/\[//g' | sed 's/\]//g' | tr -d '"' || echo "none")
          if [ "$cmd" != "none" ] && [ "$cmd" != "<no value>" ] && [ -n "$cmd" ]; then
            echo "  - CMD: $cmd"
          fi

        else
          echo "‚ùå Unable to inspect image: $image_name"
        fi

        echo "::endgroup::"

    - name: Image Security and Quality Check
      if: success() && inputs.push_image != 'true'
      shell: bash
      run: |
        echo "::group::Image Security and Quality Check"

        image_name="${{ inputs.image_name }}:${{ inputs.version }}"

        echo "üîç Running image quality checks..."

        # Check for common security issues
        echo ""
        echo "üõ°Ô∏è Basic Security Checks:"

        # Check if image runs as root
        user=$(docker image inspect "$image_name" --format '{{.Config.User}}' 2>/dev/null || echo "")
        if [ -z "$user" ] || [ "$user" = "root" ] || [ "$user" = "0" ]; then
          echo "  ‚ö†Ô∏è Image may run as root user (security concern)"
        else
          echo "  ‚úÖ Image runs as non-root user: $user"
        fi

        # Check image size efficiency
        echo ""
        echo "üìè Size Analysis:"
        size_mb=$(docker image inspect "$image_name" --format '{{.Size}}' 2>/dev/null | awk '{print int($1/1024/1024)}' || echo "0")

        if [ "$size_mb" -gt 2000 ]; then
          echo "  ‚ö†Ô∏è Large image size (${size_mb}MB) - consider optimization"
        elif [ "$size_mb" -gt 1000 ]; then
          echo "  ‚ÑπÔ∏è Medium image size (${size_mb}MB)"
        else
          echo "  ‚úÖ Compact image size (${size_mb}MB)"
        fi

        # Docker Scout scan if available
        echo ""
        echo "üîç Security Scanning:"
        if command -v docker scout &> /dev/null; then
          echo "Running Docker Scout security scan..."
          if timeout 60 docker scout quickview "$image_name" 2>/dev/null; then
            echo "‚úÖ Security scan completed"
          else
            echo "‚ö†Ô∏è Security scan timed out or failed"
          fi
        else
          echo "‚ÑπÔ∏è Docker Scout not available - install for security scanning"
        fi

        echo "::endgroup::"

    - name: Test Image Functionality
      if: success() && inputs.push_image != 'true'
      shell: bash
      run: |
        echo "::group::Image Functionality Test"

        image_name="${{ inputs.image_name }}:${{ inputs.version }}"

        echo "üß™ Testing image functionality..."

        # Test 1: Basic container creation
        echo "Test 1: Container creation..."
        if timeout 30 docker create --name test-container-$$ "$image_name" > /dev/null 2>&1; then
          echo "  ‚úÖ Container creation successful"
          docker rm test-container-$$ > /dev/null 2>&1 || true
        else
          echo "  ‚ùå Container creation failed"
        fi

        # Test 2: Basic startup test (if possible)
        echo ""
        echo "Test 2: Basic startup test..."

        # Try to run container briefly to see if it starts without immediate crash
        if timeout 10 docker run --rm --name startup-test-$$ "$image_name" echo "Startup test" > /dev/null 2>&1; then
          echo "  ‚úÖ Basic startup successful"
        else
          # This might be expected for web applications
          echo "  ‚ÑπÔ∏è Container requires specific runtime environment (normal for web apps)"
        fi

        # Test 3: Check for common issues
        echo ""
        echo "Test 3: Configuration validation..."

        # Check if required ports are exposed (if we know the expected port)
        if docker image inspect "$image_name" --format '{{range $port, $config := .Config.ExposedPorts}}{{$port}}{{end}}' 2>/dev/null | grep -q "8182"; then
          echo "  ‚úÖ Expected port 8182 is exposed"
        else
          echo "  ‚ÑπÔ∏è Port 8182 not explicitly exposed (may be configured at runtime)"
        fi

        echo ""
        echo "üéâ Image functionality tests completed"
        echo "‚úÖ Image is ready for deployment"

        echo "::endgroup::"

