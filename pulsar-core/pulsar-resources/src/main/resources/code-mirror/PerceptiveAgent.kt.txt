package ai.platon.pulsar.skeleton.ai

import ai.platon.pulsar.common.Strings
import ai.platon.pulsar.skeleton.ai.support.ExtractionSchema
import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.databind.JsonNode
import java.util.*

data class ActionOptions(
    val action: String,  // the user's action command
    val modelName: String? = null,
    val variables: Map<String, String>? = null,
    val domSettleTimeoutMs: Int? = null,
    // reserved
    val timeoutMs: Int? = null,
    // reserved
    val iframes: Boolean? = null,
    @get:JsonIgnore
    val resolve: Boolean = true,
    @get:JsonIgnore
    val multiAct: Boolean = false,
    @get:JsonIgnore
    val additionalContext: MutableMap<String, Any> = mutableMapOf(),
)

data class ActResult constructor(
    val success: Boolean = false,
    val message: String = "",

    val action: String? = null,
    val result: ToolCallResult? = null,
    // internal
    @get:JsonIgnore
    val detail: DetailedActResult? = null
) {
    /**
     * Check if the task is complete
     * */
    val isComplete: Boolean = detail?.actionDescription?.isReallyComplete == true

    /**
     * Expression with weak parameter types
     * */
    @get:JsonIgnore
    val expression get() = result?.actionDescription?.expression

    @get:JsonIgnore
    val tcEvalValue get() = result?.evaluate?.value

    override fun toString(): String {
        val eval = Strings.compactInline(tcEvalValue?.toString(), 50)
        return "[$action] expr: $expression eval: $eval message: $message"
    }
}

data class ExtractOptions(
    val instruction: String,
    val schema: ExtractionSchema,
    // reserved
    val modelName: String? = null,
    // reserved
    val modelClientOptions: Map<String, Any>? = null,
    val domSettleTimeoutMs: Long? = null,
    // reserved
    val selector: String? = null,
    // reserved
    val iframes: Boolean? = null,
    // reserved
    val frameId: String? = null,
    val agentState: AgentState? = null,
)

data class ExtractResult(
    val success: Boolean,
    val message: String = "",
    val data: JsonNode
) {
    override fun toString(): String {
        return "success: $success message: $message data: " + Strings.compactInline(data.toString(), 50)
    }
}

data class ObserveOptions(
    val instruction: String? = null,
    val modelName: String? = null,
    val modelClientOptions: Map<String, Any>? = null,
    val domSettleTimeoutMs: Long? = null,
    val returnAction: Boolean? = null,

    val drawOverlay: Boolean = true,
    // reserved
    val iframes: Boolean? = null,
    // reserved
    val frameId: String? = null,

    val resolve: Boolean = false,

    // internal
    @get:JsonIgnore
    val agentState: AgentState? = null,
    // internal
    @get:JsonIgnore
    val additionalContext: MutableMap<String, Any> = mutableMapOf(),
)

interface PerceptiveAgent : AutoCloseable {
    val uuid: UUID

    /**
     * The agent state history exists to give the AI agent a concise, sequential memory of what has been done.
     * This helps the model select the next step and summarize outcomes.
     * For this to work well, the history should reflect only the agentâ€™s actual, single-step actions
     * with clear success/failure signals and the observation context that impacted/was impacted by the action.
     * */
    val stateHistory: List<AgentState>

    /**
     * The process trace.
     * */
    val processTrace: List<ProcessTrace>

    /**
     * High-level problem resolution entry. Implementations should construct an [ActionOptions]
     * from the raw problem string and delegate to [resolve] with the options.
     *
     * @param problem The user goal or instruction to fulfill.
     * @return The final action result produced by the agent.
     */
    suspend fun resolve(problem: String): ActResult

    /**
     * Run an autonomous loop (observe -> act -> ...) attempting to fulfill the user goal described
     * in the provided [ActionOptions]. Implementations may apply retry and timeout strategies; they
     * should record structured traces while keeping [stateHistory] focused on executed tool actions only.
     *
     * @param action The action options describing the user goal and context.
     * @return The final action result for the resolution attempt.
     */
    suspend fun resolve(action: ActionOptions): ActResult

    /**
     * Convenience overload to observe by instruction string. Implementations typically create
     * an [ObserveOptions] from the instruction and delegate to [observe].
     *
     * @param instruction The observation instruction from the user.
     * @return Zero or more observation results describing candidate elements and potential actions.
     */
    suspend fun observe(instruction: String): List<ObserveResult>

    /**
     * Observe the page given an instruction and options, returning zero or more [ObserveResult]
     * objects describing candidate elements and potential actions. When `returnAction=true`,
     * implementations may include an actionable method/arguments in the result.
     *
     * @param options Observation options including the instruction and flags.
     * @return A list of observation results; empty if nothing actionable is found.
     */
    suspend fun observe(options: ObserveOptions): List<ObserveResult>

    /**
     * Convenience wrapper building [ActionOptions] from a raw action string and delegating to [act].
     *
     * @param action The action to execute.
     * @return The result of executing the action.
     */
    suspend fun act(action: String): ActResult

    /**
     * Execute a single observe->act cycle for the supplied [ActionOptions]. Implementations may
     * apply a timeout to prevent indefinite hangs. Models may produce multiple candidate tool calls;
     * only one successful execution should be recorded in [stateHistory].
     *
     * @param action The action options to execute.
     * @return The action result for the attempted execution.
     */
    suspend fun act(action: ActionOptions): ActResult

    /**
     * Execute a tool call derived from a prior observation result. Implementations should perform
     * any necessary validation and update [stateHistory] on success or failure.
     *
     * @param observe The observation result containing the candidate action.
     * @return The result of executing the derived tool call.
     */
    suspend fun act(observe: ObserveResult): ActResult

    /**
     * Convenience overload for structured extraction. When only an instruction string is provided,
     * the implementation should use [ExtractionSchema.DEFAULT].
     *
     * @param instruction The extraction instruction from the user.
     * @return The extraction result produced by the model.
     */
    suspend fun extract(instruction: String): ExtractResult

    /**
     * Convenience overload for structured extraction that constrains the result with a JSON schema.
     *
     * @param instruction The extraction instruction from the user.
     * @param schema The JSON schema used to constrain the returned data structure.
     * @return The extraction result produced by the model.
     */
    suspend fun extract(instruction: String, schema: ExtractionSchema): ExtractResult

    /**
     * Structured extraction entry point. Implementations should build a rich prompt with the DOM
     * snapshot and optional JSON schema to produce a structured [JsonNode] payload.
     *
     * @param options Extraction options including instruction and schema.
     * @return The extraction result.
     */
    suspend fun extract(options: ExtractOptions): ExtractResult
}
